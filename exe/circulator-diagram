#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"
require "fileutils"
require_relative "../lib/circulator"
require_relative "../lib/circulator/dot"
require_relative "../lib/circulator/plantuml"

# Parse command-line options
options = {format: "dot", require: nil, directory: "docs", separate: false, all: false}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: circulator-diagram [MODEL_NAME | --all] [options]"
  opts.separator ""
  opts.separator "Generate diagram files for Circulator state machine flows"
  opts.separator ""
  opts.separator "Arguments:"
  opts.separator "  MODEL_NAME    Name of the model class with Circulator flows (required unless --all is used)"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-a", "--all", "Generate diagrams for all classes with Circulator in their ancestry") do
    options[:all] = true
  end

  opts.on("-f", "--format FORMAT", ["dot", "plantuml"], "Output format (dot, plantuml). Default: dot") do |format|
    options[:format] = format
  end

  opts.on("-d", "--directory DIRECTORY", "Output directory. Default: docs") do |directory|
    options[:directory] = directory
  end

  opts.on("-s", "--separate", "Generate separate diagram files for each flow attribute") do
    options[:separate] = true
  end

  opts.on("-r", "--require FILE", "Require a file before loading the model (e.g., config/environment)") do |file|
    options[:require] = file
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit 0
  end

  opts.on("-v", "--version", "Show version") do
    puts "circulator-diagram #{Circulator::VERSION}"
    exit 0
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption => e
  warn "Error: #{e.message}"
  warn parser
  exit 1
end

# Check for required model name argument or --all flag
if ARGV.empty? && !options[:all]
  warn "Error: Either MODEL_NAME or --all is required"
  warn ""
  warn parser
  exit 1
end

model_name = ARGV[0] unless options[:all]

# Load the application environment
# Priority: -r option > config/environment.rb > nothing
if options[:require]
  # User specified a file to require
  require_file = options[:require]
  unless File.exist?(require_file)
    warn "Error: Required file '#{require_file}' not found"
    exit 1
  end
  require require_file
elsif File.exist?("config/environment.rb")
  # Rails application detected, load the environment
  require File.expand_path("config/environment.rb")
end

# Find all classes with Circulator in their ancestry
def find_circulator_classes
  classes = []

  # Try to force-load classes that might not be loaded yet
  # This is especially important for Rails apps with lazy loading
  if defined?(Rails) && Rails.application
    begin
      Rails.application.eager_load!
    rescue => e
      warn "Warning: Could not eager load Rails application: #{e.message}"
    end
  end

  ObjectSpace.each_object(Class) do |klass|
    # Skip anonymous classes and classes without names
    next if klass.name.nil? || klass.name.empty?

    # Check if the class responds to :flows (set up when Circulator is extended)
    next unless klass.respond_to?(:flows)

    begin
      flows = klass.flows
      next if flows.nil? || flows.empty?
    rescue => e
      # Skip classes where flows method raises an error
      warn "Warning: Could not get flows for #{klass.name}: #{e.class} - #{e.message}"
      next
    end

    classes << klass
  rescue => e
    # Skip any class that causes an error during inspection
    if ENV["DEBUG"]
      warn "Warning: Error inspecting class #{begin
        klass.name
      rescue
        "unknown"
      end}: #{e.class} - #{e.message}"
    end
    next
  end

  classes.sort_by(&:name)
end

# Generate diagram for a single model class
def generate_diagram_for_class(model_class, options)
  begin
    generator = case options[:format]
    when "plantuml"
      Circulator::PlantUml.new(model_class)
    else
      Circulator::Dot.new(model_class)
    end
  rescue => e
    raise "Failed to initialize diagram generator for #{model_class.name}: #{e.class} - #{e.message}"
  end

  # Determine base output filename and extension
  # Convert namespaced class names to directory paths
  # Something::Other becomes something/other
  class_name = model_class.name || "diagram"
  path_parts = class_name.split("::").map { |part|
    part.gsub(/([a-z])([A-Z])/, '\1_\2').downcase
  }
  base_name = path_parts.join("/")

  if options[:separate]
    # Generate separate diagram file for each flow attribute
    diagrams = generator.generate_separate
    extension = (options[:format] == "plantuml") ? ".puml" : ".dot"

    diagrams.each do |attribute_name, content|
      # Create filename with attribute name
      output_file = File.join(options[:directory], "#{base_name}_#{attribute_name}#{extension}")

      # Create directory if needed
      dir = File.dirname(output_file)
      FileUtils.mkdir_p(dir) unless File.exist?(dir)

      File.write(output_file, content)
      puts "Generated #{options[:format]} file: #{output_file}"
    end

    puts ""
    puts "To create images, run:"
    if options[:format] == "plantuml"
      puts "  plantuml #{File.join(options[:directory], "#{base_name}_*#{extension}")}"
    else
      diagrams.keys.each do |attribute_name|
        output_file = File.join(options[:directory], "#{base_name}_#{attribute_name}#{extension}")
        puts "  dot -Tpng #{output_file} -o #{File.join(options[:directory], "#{base_name}_#{attribute_name}")}.png"
      end
    end
  else
    # Generate single combined diagram file
    content = generator.generate

    if options[:format] == "plantuml"
      # Use model class name for PlantUML files
      output_file = File.join(options[:directory], "#{base_name}.puml")

      # Create directory if needed
      dir = File.dirname(output_file)
      FileUtils.mkdir_p(dir) unless File.exist?(dir)

      File.write(output_file, content)
      puts "Generated PlantUML file: #{output_file}"
      puts "To create an image, run:"
      puts "  plantuml #{output_file}"
    else
      # Use model class name for DOT files
      output_file = File.join(options[:directory], "#{base_name}.dot")

      # Create directory if needed
      dir = File.dirname(output_file)
      FileUtils.mkdir_p(dir) unless File.exist?(dir)

      File.write(output_file, content)
      puts "Generated DOT file: #{output_file}"
      puts "To create an image, run:"
      puts "  dot -Tpng #{output_file} -o #{File.join(options[:directory], base_name)}.png"
    end
  end
end

# Collect classes to generate diagrams for
begin
  if options[:all]
    # Find all classes with Circulator in their ancestry
    begin
      classes_to_process = find_circulator_classes
    rescue => e
      warn "Error finding Circulator classes: #{e.class} - #{e.message}"
      warn e.backtrace.first(10).join("\n")
      exit 1
    end

    if classes_to_process.empty?
      warn "No classes with Circulator flows found"
      exit 1
    end

    puts "Found #{classes_to_process.size} class(es) with Circulator flows:"
    classes_to_process.each do |klass|
      puts "  - #{klass.name}"
    end
    puts ""
  else
    # Try to constantize the model name
    begin
      model_class = Object.const_get(model_name)
    rescue NameError
      warn "Error: Model '#{model_name}' not found"
      warn "Make sure the model is loaded in your environment"
      exit 1
    end

    classes_to_process = [model_class]
  end

  # Generate diagrams for all classes in the array
  classes_to_process.each do |model_class|
    if classes_to_process.size > 1
      puts "Generating diagram for #{model_class.name}..."
    end

    begin
      generate_diagram_for_class(model_class, options)
    rescue => e
      warn "Error generating diagram for #{model_class.name}: #{e.class} - #{e.message}"
      warn e.backtrace.first(5).join("\n") if ENV["DEBUG"]
      next
    end

    puts "" if classes_to_process.size > 1
  end

  exit 0
rescue ArgumentError => e
  warn "Error: #{e.message}"
  exit 1
rescue => e
  warn "Error: #{e.class} - #{e.message}"
  warn e.backtrace.first(5).join("\n") if ENV["DEBUG"]
  exit 1
end
